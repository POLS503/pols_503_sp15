---
title: "Imputing Missing Data"
author: "Jeffrey B. Arnold"
date: "05/19/2015"
output: html_document
---

```{r message = FALSE}
library("car")
library("dplyr")
library("tidyr")
library("broom")
library("ggplot2")
library("Amelia")
```


```{r}
UN <- read.table("http://socserv.socsci.mcmaster.ca/jfox/Books/Applied-Regression-3E/datasets/UnitedNations.txt") %>%
  add_rownames(var = "country") %>%
  mutate(illiteracyMale = illiteracyMale / 100,
         illiteracyFemale = illiteracyFemale / 100,
         economicActivityMale = economicActivityMale / 100,
         economicActivityFemale = economicActivityFemale / 100,
         contraception = contraception / 100)
```

Data File: UnitedNations.txt
Source: Downloaded from http://www.un.org/Depts/unsd/social/main.htm in 1998.
Variables:
region: Africa, America, Asia, Europe, Oceania.
tfr: Total fertility rate, number of children per woman.
contraception: Percentage of married women using any method of contraception.
educationMale: Average number of years of education for men.
educationFemale: Average number of years of education for women.
lifeMale: Expectation of life at birth for men.
lifeFemale: Expectation of life at birth for women.
infantMortality: infant deaths per 1000 live births.
GDPperCapita: Gross domestic product per person in U.S. dollars.
economicActivityMale: Percentage of men who are economically active.
economicActivityFemale: Percentage of women who are economically active.
illiteracyMale: Percentage of males 15 years of age and older who are illiterate.
illiteracyFemale: Percentage of females 15 years of age and older who are illiterate. 

```{r}
fill_na <- function(x, fill = 0) {
  x[is.na(x)] <- fill
  x
}

frac_missing <- function(x) {
  sum(is.na(x)) / length(x)
}
```


```{r}
summary(UN)
```

The highest amount of missingness is in `educationMale` and `educationFemale` 
with approximately 60%.
```{r warning = FALSE}
UN %>%
  gather(variable, value) %>%
  group_by(variable) %>%
  summarise(missing = frac_missing(value)) %>%
  arrange(- missing)

```

The function `missmap` in **Amelia** is a useful way to view the missingness of the data.
```{r}
missmap(UN)
```

The model we would like to estimate is to regress Infant Mortality on 
log GDP, contraception and Female Education.

Method 1: listwise deletion is the default in R.
```{r}
mod_listwise <- 
  lm(infantMortality ~ log(GDPperCapita) + contraception + educationFemale, 
     data = UN)
summary(mod_listwise)
```
Note that 145 observations were deleted due to missingness.

One common ad-hoc method of replacing missing values is to add a dummy variable to indicate missing values for a variable, and replace the missing values in that variable with either 0's or the mean values (they are equivalent):
```{r}
UN_with_dummies <- 
  UN %>%
  mutate(GDPperCapita_na = as.integer(is.na(GDPperCapita)),
         GDPperCapita = fill_na(GDPperCapita, 1),
         contraception_na = as.integer(is.na(contraception)),
         contraception = fill_na(contraception, 0),
         educationFemale_na = as.integer(is.na(educationFemale)),
         educationFemale = fill_na(educationFemale, 0))
mod_dummies <- lm(infantMortality ~ log(GDPperCapita) + GDPperCapita_na + contraception + 
     contraception_na + educationFemale + educationFemale, data = UN_with_dummies)
mod_dummies
```

Another common ad-hoc missing data method is to replace the missing values with the mean of each variable.
```{r}
UN_with_means <- 
  UN %>%
  mutate(GDPperCapita = fill_na(GDPperCapita, mean(GDPperCapita, na.rm = TRUE)),
         contraception = fill_na(contraception, mean(contraception, na.rm = TRUE)),
         educationFemale = fill_na(educationFemale, mean(educationFemale, na.rm = TRUE)))
mod_means <- lm(infantMortality ~ log(GDPperCapita) + contraception + 
      educationFemale, data = UN_with_means)
mod_means
```

The preferred method of dealing with missing data is multiple imputation. 
We 
```{r message = FALSE, results = 'hide'}
UN_mi <- 
  amelia(UN,
         m = 10,
         logs = c("GDPperCapita"),
         lgstc = c("economicActivityMale", "economicActivityFemale",
                   "illiteracyMale", "illiteracyFemale", "contraception"),
         noms = c("region"),
         idvars = "country")

```

Amelia suggests several diagnostics for evaluating
The first is "overimputation".
This is similar to leave-one-out cross validation.
Each observation is removed and treated as a missing value to be imputated.
Amelia plots 90% confidence intervals for each observation against the true values. 
If the imputation is reasonable, then these confidence intervals should have 90% coverage of the true value.
The following code runs the overimputation diagnostic for the variables of interest (the ones that will be used in the regression).
The overimputation diagnostics do not suggest any issues with the imputation of these variables.
```{r}
for (var in c("GDPperCapita", "contraception", "illiteracyFemale")) {
  overimpute(UN_mi, var, main = var)
}
```

The second method is to plot the marginal density of the imputed values against observed values. 
If these appear too different, then there *may* be issues with imputation.
However, there is no particular criteria for what is **too different**, and there may be reasons why these distributions diverge; see the Amelia vignette for an example of what would be a big difference.
But if these distributions are different, then you should revisit the data to see whether imputation makes sense.
The following code performs this for each variable of interest.
The plots do not suggest any differences to be concerned about.
```{r}
for (var in c("GDPperCapita", "contraception", "illiteracyFemale")) {
  compare.density(UN_mi, var, main = var)
}

```
Now that we are satisfied that the imputations are reasonable, we run the analysis on each of the imputated datasets.
The following code runs the regression on each imputed dataset saving the coefficients to `b_out`, and the standard errors of the coefficients to `se_out`. 
These are originally saved to a list, but `rbind` converts it to a matrix with each imputations as rows and coefficients as columns.
```{r}
b_out <- list()
se_out <- list()
for (i in seq_along(UN_mi$imputations)) {
  mod <- lm(infantMortality ~ log(GDPperCapita) + contraception + educationFemale, data = UN_mi$imputations[[i]])
  b_out[[i]] <- coef(mod)
  se_out[[i]] <- sqrt(diag(vcov(mod)))
}
b_out <- do.call(rbind, b_out)
se_out <- do.call(rbind, se_out)
```
As described in Fox or Gelman, the coefficients from the imputations can be combined to calculate a single point estimate and standard error.
The function `mi.meld` does this, and returns a list with point estimates in the element `q.mi` and standard errors in `se.mi`:
```{r}
mod_mi_res <- mi.meld(q = b_out, se = se_out)
mod_mi_res
```

Now that we've estimated this model using various methods to handle missing data, let's compare the results.
First, we combine these into a single dataset.
For the results returned by `Amelia`, since there is no `tidy` function defined for Amelia objects we need to manually create a data frame consistent with those returned by `tidy`.

```{r echo = FALSE , results = 'hide'}
mi.df <- function(q, se) {
  am.m <- nrow(q)
  ones <- matrix(1, nrow = 1, ncol = am.m)
  imp.q <- (ones %*% q)/am.m
  ave.se2 <- (ones %*% (se^2))/am.m
  diff <- q - matrix(1, nrow = am.m, ncol = 1) %*% imp.q
  sq2 <- (ones %*% (diff^2))/(am.m - 1)
  R <- (am.m + 1) / am.m * ave.se2 / sq2
  gamma <- R / (R + 1)
  list(df = (am.m - 1) * (1 + am.m / (am.m + 1) * (ave.se2 / sq2)) ^ 2,
       rate_mi = gamma,
       efficiency = am.m / (am.m + gamma))
}

```


```{r}
model_comp <-
  bind_rows(tidy(mod_listwise) %>%
              mutate(model = "listwise"),
            tidy(mod_dummies) %>%
              mutate(model = "dummies"),
            tidy(mod_means) %>%
              mutate(model = "means"),
            data_frame(term = colnames(mod_mi_res$q.mi),
                       estimate = as.numeric(mod_mi_res$q.mi),
                       std.error = as.numeric(mod_mi_res$se.mi),
                       model = "mi"))

```


```{r}
ggplot(model_comp %>%
         filter(term %in% c("log(GDPperCapita)", "contraception", "educationFemale")), aes(x = model, y = estimate,
                                                                                           ymin = estimate - 2 * std.error,
                                                                                           ymax = estimate + 2 * std.error)) +
  geom_pointrange() +
  coord_flip() +
  facet_wrap(~ term, ncol = 1)

```




